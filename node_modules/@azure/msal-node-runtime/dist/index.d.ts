/// <reference types="node" />
export interface MsalNodeRuntime {
    ReadAccountByIdAsync(accountId: string, correlationId: string, callback: ReadAccountResultCallback): AsyncHandle;
    SignInAsync(windowHandle: Buffer, authParams: AuthParameters, correlationId: string, accountHint: string, callback: AuthResultCallback): AsyncHandle;
    SignInSilentlyAsync(authParams: AuthParameters, correlationId: string, callback: AuthResultCallback): AsyncHandle;
    SignInInteractivelyAsync(windowHandle: Buffer, authParams: AuthParameters, correlationId: string, accountHint: string, callback: AuthResultCallback): AsyncHandle;
    AcquireTokenSilentlyAsync(authParams: AuthParameters, correlationId: string, account: Account, callback: AuthResultCallback): AsyncHandle;
    AcquireTokenInteractivelyAsync(windowHandle: Buffer, authParams: AuthParameters, correlationId: string, account: Account, callback: AuthResultCallback): AsyncHandle;
    SignOutSilentlyAsync(clientId: string, correlationId: string, account: Account, callback: SignOutResultCallback): AsyncHandle;
    RegisterLogger(callback: LoggerCallback, isPiiEnabled: boolean): void;
    DiscoverAccountsAsync(clientId: string, correlationId: string, callback: DiscoverAccountsResultCallback): AsyncHandle;
    AuthParameters: AuthParametersConstructor;
    StartupError?: MsalRuntimeError;
}
type AuthParametersConstructor = {
    new (): AuthParameters;
};
type LoggerCallback = (message: string, logLevel: LogLevel, containsPii: boolean) => void;
type AuthResultCallback = (result: AuthResult) => void;
type DiscoverAccountsResultCallback = (result: DiscoverAccountsResult) => void;
type ReadAccountResultCallback = (result: ReadAccountResult) => void;
type SignOutResultCallback = (result: SignOutResult) => void;
export interface AuthParameters {
    CreateAuthParameters: (clientId: string, authority: string) => void;
    SetRedirectUri: (redirectUri: string) => void;
    SetRequestedScopes: (scopes: string) => void;
    SetDecodedClaims: (claims: string) => void;
    SetAccessTokenToRenew: (accessToken: string) => void;
    SetPopParams: (httpMethod: string, httpHost: string, httpPath: string, nonce: string) => void;
    SetAdditionalParameter: (key: string, value: string) => void;
}
export type AuthResult = {
    CheckError: () => void;
    idToken: string;
    rawIdToken: string;
    accessToken: string;
    authorizationHeader: string;
    grantedScopes: string;
    expiresOn: number;
    isPopAuthorization: boolean;
    telemetryData: string;
    account: Account;
};
export type MsalRuntimeError = {
    errorCode: number;
    errorStatus: number;
    errorContext: string;
    errorTag: number;
};
export type ReadAccountResult = {
    CheckError: () => void;
    account: Account;
    telemetryData: string;
};
export type SignOutResult = {
    CheckError: () => void;
    telemetryData: string;
};
export type Account = {
    accountId: string;
    homeAccountId: string;
    environment: string;
    realm: string;
    localAccountId: string;
    username: string;
    givenName: string;
    familyName: string;
    middleName: string;
    displayName: string;
    additionalFieldsJson: string;
    homeEnvironment: string;
    clientInfo: string;
};
export type DiscoverAccountsResult = {
    CheckError: () => void;
    accounts: Array<Account>;
    telemetryData: string;
};
export interface AsyncHandle {
    CancelAsyncOperation: () => void;
}
export declare enum ErrorStatus {
    Unexpected = 0,
    Reserved = 1,
    InteractionRequired = 2,
    NoNetwork = 3,
    NetworkTemporarilyUnavailable = 4,
    ServerTemporarilyUnavailable = 5,
    ApiContractViolation = 6,
    UserCanceled = 7,
    ApplicationCanceled = 8,
    IncorrectConfiguration = 9,
    InsufficientBuffer = 10,
    AuthorityUntrusted = 11,
    UserSwitched = 12,
    AccountUnusable = 13,
    UserDataRemovalRequired = 14,
    KeyNotFound = 15,
    AccountNotFound = 16
}
export declare enum LogLevel {
    Trace = 1,
    Debug = 2,
    Info = 3,
    Warning = 4,
    Error = 5,
    Fatal = 6
}
declare var msalNodeRuntime: MsalNodeRuntime;
export { msalNodeRuntime };
