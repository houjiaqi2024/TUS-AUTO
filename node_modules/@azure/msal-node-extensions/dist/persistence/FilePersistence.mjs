/*! @azure/msal-node-extensions v1.5.5 2025-02-18 */
'use strict';
import { promises } from 'fs';
import { dirname } from 'path';
import { ErrorCodes, Constants } from '../utils/Constants.mjs';
import { PersistenceError } from '../error/PersistenceError.mjs';
import { BasePersistence } from './BasePersistence.mjs';
import { isNodeError } from '../utils/TypeGuards.mjs';
import { Logger, LogLevel } from '../lib/msal-common/dist/logger/Logger.mjs';

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Reads and writes data to file specified by file location. File contents are not
 * encrypted.
 *
 * If file or directory has not been created, it FilePersistence.create() will create
 * file and any directories in the path recursively.
 */
class FilePersistence extends BasePersistence {
    constructor(fileLocation, loggerOptions) {
        super();
        this.logger = new Logger(loggerOptions || FilePersistence.createDefaultLoggerOptions());
        this.filePath = fileLocation;
    }
    static async create(fileLocation, loggerOptions) {
        const filePersistence = new FilePersistence(fileLocation, loggerOptions);
        await filePersistence.createCacheFile();
        return filePersistence;
    }
    async save(contents) {
        try {
            await promises.writeFile(this.getFilePath(), contents, "utf-8");
        }
        catch (err) {
            if (isNodeError(err)) {
                throw PersistenceError.createFileSystemError(err.code || ErrorCodes.UNKNOWN, err.message);
            }
            else {
                throw err;
            }
        }
    }
    async saveBuffer(contents) {
        try {
            await promises.writeFile(this.getFilePath(), contents);
        }
        catch (err) {
            if (isNodeError(err)) {
                throw PersistenceError.createFileSystemError(err.code || ErrorCodes.UNKNOWN, err.message);
            }
            else {
                throw err;
            }
        }
    }
    async load() {
        try {
            return await promises.readFile(this.getFilePath(), "utf-8");
        }
        catch (err) {
            if (isNodeError(err)) {
                throw PersistenceError.createFileSystemError(err.code || ErrorCodes.UNKNOWN, err.message);
            }
            else {
                throw err;
            }
        }
    }
    async loadBuffer() {
        try {
            return await promises.readFile(this.getFilePath());
        }
        catch (err) {
            if (isNodeError(err)) {
                throw PersistenceError.createFileSystemError(err.code || ErrorCodes.UNKNOWN, err.message);
            }
            else {
                throw err;
            }
        }
    }
    async delete() {
        try {
            await promises.unlink(this.getFilePath());
            return true;
        }
        catch (err) {
            if (isNodeError(err)) {
                if (err.code === Constants.ENOENT_ERROR) {
                    // file does not exist, so it was not deleted
                    this.logger.warning("Cache file does not exist, so it could not be deleted");
                    return false;
                }
                throw PersistenceError.createFileSystemError(err.code || ErrorCodes.UNKNOWN, err.message);
            }
            else {
                throw err;
            }
        }
    }
    getFilePath() {
        return this.filePath;
    }
    async reloadNecessary(lastSync) {
        return lastSync < (await this.timeLastModified());
    }
    getLogger() {
        return this.logger;
    }
    createForPersistenceValidation() {
        const testCacheFileLocation = `${dirname(this.filePath)}/test.cache`;
        return FilePersistence.create(testCacheFileLocation);
    }
    static createDefaultLoggerOptions() {
        return {
            loggerCallback: () => {
                // allow users to not set loggerCallback
            },
            piiLoggingEnabled: false,
            logLevel: LogLevel.Info,
        };
    }
    async timeLastModified() {
        try {
            const stats = await promises.stat(this.filePath);
            return stats.mtime.getTime();
        }
        catch (err) {
            if (isNodeError(err)) {
                if (err.code === Constants.ENOENT_ERROR) {
                    // file does not exist, so it's never been modified
                    this.logger.verbose("Cache file does not exist");
                    return 0;
                }
                throw PersistenceError.createFileSystemError(err.code || ErrorCodes.UNKNOWN, err.message);
            }
            else {
                throw err;
            }
        }
    }
    async createCacheFile() {
        await this.createFileDirectory();
        // File is created only if it does not exist
        const fileHandle = await promises.open(this.filePath, "a");
        await fileHandle.close();
        this.logger.info(`File created at ${this.filePath}`);
    }
    async createFileDirectory() {
        try {
            await promises.mkdir(dirname(this.filePath), { recursive: true });
        }
        catch (err) {
            if (isNodeError(err)) {
                if (err.code === Constants.EEXIST_ERROR) {
                    this.logger.info(`Directory ${dirname(this.filePath)}  already exists`);
                }
                else {
                    throw PersistenceError.createFileSystemError(err.code || ErrorCodes.UNKNOWN, err.message);
                }
            }
            else {
                throw err;
            }
        }
    }
}

export { FilePersistence };
//# sourceMappingURL=FilePersistence.mjs.map
