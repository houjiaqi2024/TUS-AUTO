/*! @azure/msal-node-extensions v1.5.5 2025-02-18 */
'use strict';
import keytar from 'keytar';
import { FilePersistence } from './FilePersistence.mjs';
import { PersistenceError } from '../error/PersistenceError.mjs';
import { dirname } from 'path';
import { BasePersistence } from './BasePersistence.mjs';
import { isNodeError } from '../utils/TypeGuards.mjs';

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Uses reads and writes passwords to Secret Service API/libsecret. Requires libsecret
 * to be installed.
 *
 * serviceName: Identifier used as key for whatever value is stored
 * accountName: Account under which password should be stored
 */
class LibSecretPersistence extends BasePersistence {
    constructor(filePersistence, serviceName, accountName) {
        super();
        this.filePersistence = filePersistence;
        this.serviceName = serviceName;
        this.accountName = accountName;
    }
    static async create(fileLocation, serviceName, accountName, loggerOptions) {
        const filePersistence = await FilePersistence.create(fileLocation, loggerOptions);
        const persistence = new LibSecretPersistence(filePersistence, serviceName, accountName);
        return persistence;
    }
    async save(contents) {
        try {
            await keytar.setPassword(this.serviceName, this.accountName, contents);
        }
        catch (err) {
            if (isNodeError(err)) {
                throw PersistenceError.createLibSecretError(err.message);
            }
            else {
                throw err;
            }
        }
        // Write dummy data to update file mtime
        await this.filePersistence.save("{}");
    }
    async load() {
        try {
            return await keytar.getPassword(this.serviceName, this.accountName);
        }
        catch (err) {
            if (isNodeError(err)) {
                throw PersistenceError.createLibSecretError(err.message);
            }
            else {
                throw err;
            }
        }
    }
    async delete() {
        try {
            await this.filePersistence.delete();
            return await keytar.deletePassword(this.serviceName, this.accountName);
        }
        catch (err) {
            if (isNodeError(err)) {
                throw PersistenceError.createLibSecretError(err.message);
            }
            else {
                throw err;
            }
        }
    }
    async reloadNecessary(lastSync) {
        return this.filePersistence.reloadNecessary(lastSync);
    }
    getFilePath() {
        return this.filePersistence.getFilePath();
    }
    getLogger() {
        return this.filePersistence.getLogger();
    }
    createForPersistenceValidation() {
        const testCacheFileLocation = `${dirname(this.filePersistence.getFilePath())}/test.cache`;
        return LibSecretPersistence.create(testCacheFileLocation, "persistenceValidationServiceName", "persistencValidationAccountName");
    }
}

export { LibSecretPersistence };
//# sourceMappingURL=LibSecretPersistence.mjs.map
